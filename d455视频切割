import pyrealsense2 as rs
import numpy as np
import cv2
import os
#rgb和伪彩色
# 加载.bag文件
bag_filename = "C://Users//testrobot1//Documents//20240321_222432.bag"
pipeline = rs.pipeline()
config = rs.config()
config.enable_device_from_file(bag_filename)
pipeline.start(config)

# 创建对齐器，用于将深度帧与其他帧对齐
align_to = rs.stream.color
align = rs.align(align_to)

# 输出目录
output_dir = r'C:\Users\testrobot1\Desktop\realsense_library_custom-main\segmentation_models.pytorch-master\data\RGB_photo\rgb'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# 输出目录（伪彩色图像）
depth_output_dir = r'C:\Users\testrobot1\Desktop\realsense_library_custom-main\segmentation_models.pytorch-master\data\RGB_photo\depth'
if not os.path.exists(depth_output_dir):
    os.makedirs(depth_output_dir)

try:
    frame_count = 0
    max_frames = 35  # 设置最大帧数为35
    while True:
        # 等待一帧数据
        frames = pipeline.wait_for_frames()

        # 通过对齐器获取对齐的深度帧和颜色帧
        aligned_frames = align.process(frames)
        depth_frame = aligned_frames.get_depth_frame()
        color_frame = aligned_frames.get_color_frame()

        if not depth_frame or not color_frame:
            continue

        # 将颜色帧数据转换为OpenCV图像格式
        color_data = color_frame.as_frame().get_data()
        color_image = np.asanyarray(color_data)
        color_image = cv2.cvtColor(color_image, cv2.COLOR_BGR2RGB)

        # 在这里对颜色图像进行处理，比如显示或保存等
        # 例如，你可以使用OpenCV来显示颜色图像
        cv2.imshow("Color Frame", color_image)

        # 每隔五帧将当前画面转换为jpg格式并输出，最多输出35张图片
        if frame_count % 5 == 0 and frame_count // 5 < max_frames:
            output_path = os.path.join(output_dir, f"frame_{frame_count // 5}.jpg")
            cv2.imwrite(output_path, color_image)
            print(f"Saved frame {frame_count // 5} as {output_path}")

            # 将深度帧映射到伪彩色图像
            colorized_depth = cv2.applyColorMap(cv2.convertScaleAbs(np.asanyarray(depth_frame.get_data()), alpha=0.03), cv2.COLORMAP_JET)
            depth_output_path = os.path.join(depth_output_dir, f"depth_frame_{frame_count // 5}.jpg")
            cv2.imwrite(depth_output_path, colorized_depth)
            print(f"Saved depth frame {frame_count // 5} as {depth_output_path}")

        frame_count += 1

        if cv2.waitKey(1) & 0xFF == ord('q') or frame_count // 5 >= max_frames:
            break

finally:
    pipeline.stop()
    cv2.destroyAllWindows()
